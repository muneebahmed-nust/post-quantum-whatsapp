// deno-lint-ignore-file no-explicit-any
/**
 * This file is based on noble-hashes (https://github.com/paulmillr/noble-hashes).
 *
 * noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com)
 *
 * The original file is located at:
 * https://github.com/paulmillr/noble-hashes/blob/4e358a46d682adfb005ae6314ec999f2513086b9/src/utils.ts
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.oidNist = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
    exports.isBytes = isBytes;
    exports.anumber = anumber;
    exports.abytes = abytes;
    exports.aexists = aexists;
    exports.aoutput = aoutput;
    exports.u32 = u32;
    exports.clean = clean;
    exports.byteSwap = byteSwap;
    exports.byteSwap32 = byteSwap32;
    exports.hexToBytes = hexToBytes;
    exports.utf8ToBytes = utf8ToBytes;
    exports.bytesToUtf8 = bytesToUtf8;
    exports.concatBytes = concatBytes;
    exports.createHasher = createHasher;
    /**
     * Utilities for hex, bytes, CSPRNG.
     * @module
     */
    /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    /** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */
    function isBytes(a) {
        return a instanceof Uint8Array ||
            (ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array");
    }
    /** Asserts something is positive integer. */
    function anumber(n, title = "") {
        if (!Number.isSafeInteger(n) || n < 0) {
            const prefix = title && `"${title}" `;
            throw new Error(`${prefix}expected integer >0, got ${n}`);
        }
    }
    /** Asserts something is Uint8Array. */
    function abytes(value, length, title = "") {
        const bytes = isBytes(value);
        const len = value?.length;
        const needsLen = length !== undefined;
        if (!bytes || (needsLen && len !== length)) {
            const prefix = title && `"${title}" `;
            const ofLen = needsLen ? ` of length ${length}` : "";
            const got = bytes ? `length=${len}` : `type=${typeof value}`;
            throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
        }
        return value;
    }
    /** Asserts a hash instance has not been destroyed / finished */
    function aexists(instance, checkFinished = true) {
        if (instance.destroyed)
            throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished) {
            throw new Error("Hash#digest() has already been called");
        }
    }
    /** Asserts output is properly-sized byte array */
    function aoutput(out, instance) {
        abytes(out, undefined, "digestInto() output");
        const min = instance.outputLen;
        if (out.length < min) {
            throw new Error('"digestInto() output" expected to be of length >=' + min);
        }
    }
    /** Cast u8 / u16 / u32 to u32. */
    function u32(arr) {
        return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    /** Zeroize a byte array. Warning: JS provides no guarantees. */
    function clean(...arrays) {
        for (let i = 0; i < arrays.length; i++) {
            arrays[i].fill(0);
        }
    }
    /** Is current platform little-endian? Most are. Big-Endian platform: IBM */
    exports.isLE = 
    /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();
    /** The byte swap operation for uint32 */
    function byteSwap(word) {
        return (((word << 24) & 0xff000000) |
            ((word << 8) & 0xff0000) |
            ((word >>> 8) & 0xff00) |
            ((word >>> 24) & 0xff));
    }
    /** Conditionally byte swap if on a big-endian platform */
    exports.swap8IfBE = exports.isLE
        ? (n) => n
        : (n) => byteSwap(n);
    /** @deprecated */
    exports.byteSwapIfBE = exports.swap8IfBE;
    /** In place byte swap for Uint32Array */
    function byteSwap32(arr) {
        for (let i = 0; i < arr.length; i++) {
            arr[i] = byteSwap(arr[i]);
        }
        return arr;
    }
    exports.swap32IfBE = exports.isLE
        ? (u) => u
        : byteSwap32;
    // Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
    const hasHexBuiltin = /* @__PURE__ */ (() => 
    // @ts-ignore: to check the existence of the method
    typeof Uint8Array.from([]).toHex === "function" &&
        // @ts-ignore: to check the existence of the method
        typeof Uint8Array.fromHex === "function")();
    // We use optimized technique to convert hex string to byte array
    const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
        if (ch >= asciis._0 && ch <= asciis._9)
            return ch - asciis._0; // '2' => 50-48
        if (ch >= asciis.A && ch <= asciis.F)
            return ch - (asciis.A - 10); // 'B' => 66-(65-10)
        if (ch >= asciis.a && ch <= asciis.f)
            return ch - (asciis.a - 10); // 'b' => 98-(97-10)
        return;
    }
    /**
     * Convert hex string to byte array. Uses built-in function, when available.
     * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
     */
    function hexToBytes(hex) {
        if (typeof hex !== "string") {
            throw new Error("hex string expected, got " + typeof hex);
        }
        // @ts-ignore: to check the existence of the method
        if (hasHexBuiltin)
            return Uint8Array.fromHex(hex);
        const hl = hex.length;
        const al = hl / 2;
        if (hl % 2) {
            throw new Error("hex string expected, got unpadded hex of length " + hl);
        }
        const array = new Uint8Array(al);
        for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
            const n1 = asciiToBase16(hex.charCodeAt(hi));
            const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
            if (n1 === undefined || n2 === undefined) {
                const char = hex[hi] + hex[hi + 1];
                throw new Error('hex string expected, got non-hex character "' + char + '" at index ' +
                    hi);
            }
            array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
        }
        return array;
    }
    /**
     * Converts string to bytes using UTF8 encoding.
     * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])
     */
    function utf8ToBytes(str) {
        if (typeof str !== "string")
            throw new Error("string expected");
        return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
    }
    /**
     * Converts bytes to string using UTF8 encoding.
     * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
     */
    function bytesToUtf8(bytes) {
        return new TextDecoder().decode(bytes);
    }
    /** Copies several Uint8Arrays into one. */
    function concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
            const a = arrays[i];
            abytes(a);
            sum += a.length;
        }
        const res = new Uint8Array(sum);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
            const a = arrays[i];
            res.set(a, pad);
            pad += a.length;
        }
        return res;
    }
    function createHasher(hashCons, info = {}) {
        const hashC = (msg, opts) => hashCons(opts).update(msg).digest();
        const tmp = hashCons(undefined);
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        Object.assign(hashC, info);
        return Object.freeze(hashC);
    }
    // 06 09 60 86 48 01 65 03 04 02
    const oidNist = (suffix) => ({
        oid: Uint8Array.from([
            0x06,
            0x09,
            0x60,
            0x86,
            0x48,
            0x01,
            0x65,
            0x03,
            0x04,
            0x02,
            suffix,
        ]),
    });
    exports.oidNist = oidNist;
});
